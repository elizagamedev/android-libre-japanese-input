// Copyright 2010-2018, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
package sh.eliza.japaneseinput.accessibility

import android.content.Context
import android.os.Handler
import android.os.Looper
import android.os.Message
import android.view.MotionEvent
import android.view.View
import android.view.ViewGroup
import android.view.accessibility.AccessibilityEvent
import android.view.accessibility.AccessibilityManager
import android.view.accessibility.AccessibilityNodeInfo
import androidx.core.view.AccessibilityDelegateCompat
import androidx.core.view.accessibility.AccessibilityNodeProviderCompat
import sh.eliza.japaneseinput.R
import sh.eliza.japaneseinput.accessibility.AccessibilityEventUtil.createAccessibilityEvent
import sh.eliza.japaneseinput.keyboard.Flick
import sh.eliza.japaneseinput.keyboard.Key
import sh.eliza.japaneseinput.keyboard.KeyEntity
import sh.eliza.japaneseinput.keyboard.KeyState.MetaState
import sh.eliza.japaneseinput.keyboard.Keyboard

/** Delegate object for Keyboard view to support accessibility. */
class KeyboardAccessibilityDelegate(
  private val view: View,
  private val emulator: TouchEventEmulator
) : AccessibilityDelegateCompat() {
  private val accessibilityManager =
    view.context.getSystemService(Context.ACCESSIBILITY_SERVICE) as AccessibilityManager

  private var lastHoverKey: Key? = null
  private val nodeProvider = KeyboardAccessibilityNodeProvider(view)

  // Delay for long-press detection (in ms).
  private val longpressDelay =
    view.context.resources.getInteger(R.integer.config_long_press_key_delay_accessibility)

  // Handler for long-press callback.
  // Contains 0 or 1 delayed message.
  private val handler = Handler(Looper.getMainLooper(), LongTapHandler())

  // True if the touch sequence is consumed by long-press.
  // In such case touch-up shouldn't send any key events.
  // Reset to false when new touch sequence is started.
  private var consumedByLongpress = false

  /** Emulator interface for touch events (Key input and long press). */
  interface TouchEventEmulator {
    fun emulateKeyInput(key: Key?)
    fun emulateLongPress(key: Key?)
  }

  private inner class LongTapHandler : Handler.Callback {
    override fun handleMessage(msg: Message): Boolean {
      val lastHoverKey = lastHoverKey
      if (lastHoverKey != null) {
        simulateLongPress(lastHoverKey)
      }
      return true
    }
  }

  private val context: Context
    get() = view.context

  /**
   * Intercepts touch events before dispatch when touch exploration is turned on in ICS and higher.
   *
   * @param event The motion event being dispatched.
   * @return `true` if the event is handled
   */
  fun dispatchTouchEvent(@Suppress("UNUSED_PARAMETER") event: MotionEvent?): Boolean {
    // To avoid accidental key presses during touch exploration, always drop
    // touch events generated by the user.
    return false
  }

  /**
   * Dispatched from `View#dispatchHoverEvent`.
   *
   * @return `true` if the event was handled by the view, false otherwise
   */
  fun dispatchHoverEvent(event: MotionEvent): Boolean {
    val key = nodeProvider.getKey(event.x.toInt(), event.y.toInt())
    val lastHoverKey = lastHoverKey
    when (event.action) {
      MotionEvent.ACTION_HOVER_ENTER -> {
        check(lastHoverKey == null)
        consumedByLongpress = false
        if (key != null) {
          // Notify the user that we are entering new virtual view.
          nodeProvider.sendAccessibilityEventForKeyIfAccessibilityEnabled(
            key,
            AccessibilityEvent.TYPE_VIEW_HOVER_ENTER
          )
          // Make virtual view focus on the key.
          nodeProvider.performActionForKey(key, AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS)
          // Register singleton message for long-press.
          handler.removeMessages(LONGPRESS_WHAT_VALUE)
          handler.sendMessageDelayed(
            handler.obtainMessage(LONGPRESS_WHAT_VALUE, 0, 0, context),
            longpressDelay.toLong()
          )
        }
        this.lastHoverKey = key
      }
      MotionEvent.ACTION_HOVER_EXIT -> {
        if (key != null) {
          simulateKeyInput(key)
          // Notify the user that we are exiting from the key.
          nodeProvider.sendAccessibilityEventForKeyIfAccessibilityEnabled(
            key,
            AccessibilityEvent.TYPE_VIEW_HOVER_EXIT
          )
          // Make virtual view unfocused.
          nodeProvider.performActionForKey(
            key,
            AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS
          )
        }
        this.lastHoverKey = null
        // Remove all the long-press messages.
        handler.removeMessages(LONGPRESS_WHAT_VALUE)
      }
      MotionEvent.ACTION_HOVER_MOVE -> {
        if (key != lastHoverKey) {
          if (lastHoverKey != null) {
            // Notify the user that we are exiting from lastHoverKey.
            nodeProvider.sendAccessibilityEventForKeyIfAccessibilityEnabled(
              lastHoverKey,
              AccessibilityEvent.TYPE_VIEW_HOVER_EXIT
            )
            // Make virtual view unfocused.
            nodeProvider.performActionForKey(
              lastHoverKey,
              AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS
            )
          }
          if (key != null) {
            // Notify the user that we are entering new virtual view.
            nodeProvider.sendAccessibilityEventForKeyIfAccessibilityEnabled(
              key,
              AccessibilityEvent.TYPE_VIEW_HOVER_ENTER
            )
            // Make virtual view focus on the key.
            nodeProvider.performActionForKey(key, AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS)
            // Register singleton message for long-press.
            handler.removeMessages(LONGPRESS_WHAT_VALUE)
            handler.sendMessageDelayed(
              handler.obtainMessage(LONGPRESS_WHAT_VALUE, 0, 0, context),
              longpressDelay.toLong()
            )
          }
          this.lastHoverKey = key
        }
      }
    }
    return key != null
  }

  private fun simulateKeyInput(key: Key) {
    val keyState = key.getKeyState(emptySet())
    if (!keyState.isPresent) {
      return
    }
    val keyCode = keyState.get().getFlick(Flick.Direction.CENTER).get().keyEntity.keyCode
    if (keyCode == KeyEntity.INVALID_KEY_CODE || consumedByLongpress) {
      return
    }
    emulator.emulateKeyInput(key)
  }

  private fun simulateLongPress(key: Key) {
    val keyState = key.getKeyState(emptySet())
    if (!keyState.isPresent) {
      return
    }
    val longPressKeyCode =
      keyState.get().getFlick(Flick.Direction.CENTER).get().keyEntity.longPressKeyCode
    if (longPressKeyCode == KeyEntity.INVALID_KEY_CODE || consumedByLongpress) {
      return
    }
    emulator.emulateLongPress(key)
    consumedByLongpress = true
  }

  override fun getAccessibilityNodeProvider(host: View): AccessibilityNodeProviderCompat {
    return nodeProvider
  }

  /**
   * Sets metastate of the keyboard.
   *
   * Node provider's internal state is reset here.
   */
  fun setMetaState(metaState: Set<MetaState>) {
    nodeProvider.setMetaState(metaState)
  }

  /**
   * Sets the keyboard.
   *
   * Node provider's internal state is reset here.
   */
  fun setKeyboard(keyboard: Keyboard?) {
    nodeProvider.setKeyboard(keyboard)
    if (accessibilityManager.isEnabled) {
      val contentDescription = keyboard?.contentDescription?.orNull()
      sendWindowStateChanged(contentDescription)
    }
  }

  /**
   * Sends a window state change event with the specified text.
   *
   * @param newContentDescription the text to send with the event as content description
   */
  private fun sendWindowStateChanged(newContentDescription: String?) {
    val stateChange = createAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED)
    view.onInitializeAccessibilityEvent(stateChange)
    stateChange.contentDescription = newContentDescription
    requestSendAccessibilityEventIfPossible(stateChange)
  }

  /** Sends an AccessibilityEvent throuth `view`'s parent. If the API Level is <14, does nothing. */
  private fun requestSendAccessibilityEventIfPossible(event: AccessibilityEvent) {
    val viewParent = view.parent
    if (viewParent == null || viewParent !is ViewGroup) {
      return
    }
    // requestSendAccessibilityEvent is since API Level 14 (ICS).
    // No fallback is provided for older framework. Just ignore.
    viewParent.requestSendAccessibilityEvent(view, event)
  }
}

// "what" value of a Message.
private const val LONGPRESS_WHAT_VALUE = 1
